# WalGoDb

### Синтаксис запросов

Грамматика языка запросов в виде eBNF:
```
query = set_command | get_command | del_command

set_command = "SET" argument argument
get_command = "GET" argument
del_command = "DEL" argument
argument    = punctuation | letter | digit { punctuation | letter | digit }

punctuation = "*" | "/" | "_" | ...
letter      = "a" | ... | "z" | "A" | ... | "Z"
digit       = "0" | ... | "9"
```

### Пример запросов:
```
SET weather_2_pm cold_moscow_weather
GET /etc/nginx/config
DEL user_****
```

То есть, синтаксис очень простой - есть всего лишь три возможных команды (SET, GET, DEL - регистрозависимые), аргументами команд являются только следующая возможная комбинация /(\w+)/g , разделителями являются любые пробельные символы.



### Особенности реализации

Взаимодействие с базой данных на данном этапе должно осуществляться только лишь через командную строку, то есть вы запускаете базу данных и взаимодействуете с ней через командую строку с использованием языка запросов. Никакие данные на жесткий диск сейчас дампить не нужно (если вы сделали рестарт базы данных, то все данные должны будут пропасть)

В качестве engine пишем in-memory движок, который просто будет хранить данные в виде хэш-таблицы (в качестве ключей и запросов только текстовые типы данных).

Необходимо сразу задуматься над логированием, поэтому следует логировать ключевые моменты обработки запросов (в качестве библиотеки логирования можно выбрать zap)

Покрываем код тестами, особенно это касается компонентов parser, analyzer внутри compute слоя и компонента engine внутри storage слоя (суммарное покрытие кода тестами должно быть не менее 90%)

### Домашнее задание №2

Необходимо реализовать TCP сервер для базы данных (внутри существующего приложения), чтобы с ним можно было бы взаимодействовать по сети.

Протокол общения с сервером базы данных будет текстовым, то есть запросы будут передаваться в точно таком же формате, как и до этого вы вводили в командной строке.

Также необходимо реализовать отдельное приложение CLI клиент (можно в виде отдельного main.go файла), с помощью которого вы будете дальше взаимодействовать с вашей базой данных. По сути это приложение должно состоять только лишь из TCP клиента и удобного интерфейса командной строки для работы с вашей базой данных.

### Конфигурация

В этом домашнем задании вам нужно реализовать возможность конфигурации вашей базы данных из yaml файла. В этом файле можно будет указать параметры сетевого соединения, вид движка (у нас только in_memory, но тем не менее), а также уровень логирования. В будущем эта конфигурация будет только расширяться. Пример файла конфигурации:

```yaml
engine:
  type: "in_memory"
network:
  address: "127.0.0.1:3223"
  max_connections: 100
  max_message_size: "4KB"
  idle_timeout: 5m
logging:
  level: "info"
  output: "/log/output.log"
```

### Особенности реализации

* Каждый клиент должен обрабатываться в отдельной горутине, важно не забыть про синхронизацию работы этих клиентов с хэш-таблицей, где хранятся данные
* Следует реализовать ограничитель количества одновременных соединений с вашим сервером базы данных - это значит, что ваш сервер должен уметь одновременно обрабатывать не больше, чем N клиентов
* Следует реализовать конфигурирование вашей базы данных таким образом, что если не задан какой-либо параметр конфигурации, то должны использоваться параметры по умолчанию, а не завершать приложение с ошибкой конфигурации
* Следует реализовать возможность конфигурирования CLI клиента с использованием аргументов командной строки, например вот так: ./database_client —-address=localhost:3223
* Покрываем код тестами, особенно это касается слоя сетевого взаимодействия и конфигурирования базы данных (суммарное покрытие кода тестами должно быть не менее 90%)
